# 캐시 스탬피드(Cache Stampede)
## 레디스 캐싱 전략

### 캐시?? 캐싱??

#### 캐시(cache)

데이터를 미리 복사해 놓는 임시 저장소를 의미한다. 캐시를 이용하지 않았을 때의 데이터 접근 시간이 오래 걸리는 경우나 값을 다시 연산하는 시간을 단축하기 위해 사용된다. 데이터가 본래 저장되어 있던 장소보다 접근 시간이 더 빠른 별도의 장소에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.

캐시의 주요 목적은 더 느린 기본 스토리지 계층에 액세스해야 하는 필요를 줄임으로써 데이터 검색 성능을 높이는 것이다.

#### 캐싱(caching)

캐시에 저장된 데이터에 접근하는 방식을 말한다. 즉 캐시 데이터를 읽고 쓰는 작업을 말한다.



### 읽기 전략(look-aside)

애플리케이션이 찾고자 하는 데이터가 먼저 캐시에 있는지를 확인한 뒤, 캐시에 데이터가 있으면 캐시에서 데이터를 읽어온다. 이를 캐시 히트라고 한다. 만약 레디스로부터 데이터가 없다는 응답을 받은 애플리케이션은 직접 데이터베이스에 접근해 찾고자 하는 데이터를 가져온다. 그 뒤 애플리케이션은 다시 캐시에 저장하는 데 이를 lazy loading이라 한다. 마지막으로 미리 데이터베이스에서 캐시로 데이터를 밀어주는 작업을 캐시 워밍이라 한다.

![image-20240309151804534](/Users/sunhokim/Library/Application Support/typora-user-images/image-20240309151804534.png)

예시로 공연 애매시 상품이 오픈하기 전 미리 데이터베이스에 저장된 데이터를 레디스로 밀어넣는 방법이 있다.



### 쓰기 전략과 캐시의 일관성

캐시는 데이터베이스에 저장되어있는 데이터를 단순히 복사해 온 값이다. 따라서 원본 데이터와 동일한 값을 갖도록 유지하는 것이 필수적이다. 만약 데이터가 변경될 때 원본 데이터베이스에만 업데이트돼 캐시에는 변경된 값이 반영되지 않는다면 데이터 간 불일치가 일어난다. 이를 캐시 불일치라 한다.

#### write through

* 데이터베이스에 업데이트 할 때마다 매번 캐시에도 데이터를 함께 업데이트 시키는 방식

#### cache invalidation

* 데이터베이스에 값을 업데이트 할때마다 캐시에는 데이터를 삭제하는 전략
* 저장소에서 특정 데이터를 삭제하는 것이 새로운 데이터를 저장하는 것보다 훨씬 리소스를 적게 사용하기 때문

#### write behind

* 먼저 데이터를 빠르게 접근할 수 있는 캐시에 업데이트
* 그 다음 건수나 특정 간격 등에 따라 비동기적으로 데이터베이스에 업데이트 하는 것
* 캐시에 문제가 생겨 데이터가 날아갈 경우 데이터가 없어질 수 있다는 위험성이 내포

![image-20240309154000239](/Users/sunhokim/Library/Application Support/typora-user-images/image-20240309154000239.png)

그리고 캐시는 가득차지 않게 일정 양의 데이터를 유지해야 하며, 새로운 데이터가 저장되고 기존데이터는 삭제해야 한다. 따라서 캐시로 레디스를 사용할 때에는 데이터를 저장함과 동시에 적절한 TTL값을 지정하는 것이 좋다.



## 캐시 스탬피드 현상

#### 스탬피드?

* 한 무리의 사람이나 동물이 두려움이나 공황으로 인해 갑작스럽고 거칠고 통제할 수 없는 방식으로 달리게 하는 행위
* 서두르거나 통제할 수 없는 성급함 또는 공황 상태로 행동하는 것
* 스탬피드 현상
    * 소떼나 말이 질서 정연하게 이동하던 중 한 두마리가 뛰게 되면 나머지도 덩달아 뛰게 되어 누구도 통제할 수 없는 상태



### 캐시 스탬피드 현상이란?

레디스를 캐시로 활용할 때 모든 키에 대해 만료 시간을 설정하는 것은 권장되지만, 대규모 트래픽 환경에서 만료 시간을 어떻게 설정하느냐에 따라 캐시 스탬피드와 같은 문제 상황이 발생할 수 있다.

앞서 look aside 방식에서는 애플리케이션이 레디스에 먼저 데이터가 있는 지 질의한 후 데이터가 없을 때 데이터베이스에서 데이터를 읽어오는 방식을 반복한다.

이때 레디스에서 특정 키가 만료되는 시점을 생각해보자. 만약 여러 개의 애플리케이션이 바라보던 키가 레디스에서 만료돼 삭제된다면 이 서버들은 한 꺼번에 데이터베이스에서 데이터를 읽어오는 과정을 거친다. 이를 중복 읽기라 한다. 이후 각 애플리케이션에서는 데이터를 레디스에 쓰게 되는데, 이 또한 여러 번 반복되기 때문에 중복 쓰기가 발생한다.

![image-20240309154433693](/Users/sunhokim/Library/Application Support/typora-user-images/image-20240309154433693.png)

이 중복 읽기 작업은 데이터베이스에 부하를 줄 수 있으며, 이는 곧 서비스 이슈로도 이어질 수 있다. 한 번 캐시 스탬피드 현상이 발생하면 결과적으로 더 많은 데이터가 이 현상의 영향을 받게 돼, 더 큰 문제로 이어질 수 있다. 이 현상을 계단식 실패라고도 한다.



### 캐시 스템피드를 없애기 위한 방법

#### 적절한 만료시간 설정

* 가장 간단하게 만료시간을 너무 짧지 않게 설정하는 것
* 반복적으로 사용돼야 하는 데이터라면 저장 시점부터 만료 시간을 충분히 길게 설정

#### 선 계산

* 캐시에 데이터가 있는 지 확인한 뒤 없으면 데이터베이스에서 데이터를 가져온 뒤 다시 레디스에 저장
* 혹은 랜덤한 확률도 키가 만료되기 전 데이터를 갱신

#### PER(Probabilistic Early Recomputation) 알고리즘

이 알고리즘을 이용하면 캐시 값이 만료되기 전에 언제 데이터베이스에 접근해서 값을 읽어오면 되는지 최적으로 계산할 수 있다.

```
curremtTime - (timeToCompute * beta * log(rand())) > expiry
```

* **currentTime**: 현재 남은 만료시간
* **timeToCompute**: 캐시된 값을 다시 계산하는 데 걸리는 시간
* **beta**: 기본적으로 1.0보다 큰 값으로 설정 가능
* **rand()**: 0과 1 사이의 랜덤 값을 반환하는 함수
* **expiry**: 키를 재설정할 때 새로 넣어줄 만료시간


















































